model {
      ## Likelihood
      for(i in 1:N) {
        Y[i] ~ dnorm(mu[i], prec[i])
        prec[i] <- 1 / pow(tau[i], 2)
        mu[i] <- inprod(beta[], X[i, 1:K]) + inprod(v_final[groupid[i], 1:1], Z[i, 1:1])
        log(tau[i]) <- inprod(zeta[], X_scale[i, 1:S]) + inprod(v_final[groupid[i], 2:2], Z_scale[i, 1:1])

      }

      ## Group-Level Section
      for(j in 1:J) {

		for(p in 1:P){ z[j,p] ~ dnorm(0,1) }

		## Generate correlated random effects v = tau * L * z
				v[j,1] <- sigma_rand[1] * (L[1, 1] * z[j, 1])
				v[j,2] <- sigma_rand[2] * (L[2, 1] * z[j, 1] + L[2, 2] * z[j, 2])

		## Assign location random effects (always on)
				for (k in 1:1) {
					v_final[j, k] <- v[j, k]
				}

		## Assign scale random effects (with spike-and-slab via loop)
				for (k in 1:1) {
					delta[j, k] ~ dbern(bval[k, 1])
					v_final[j, 1 + k] <- v[j, 1 + k] * delta[j, k]
				}
      }

    ## Priors for fixed effects and variance components
	for (k in 1:K) { beta[k] ~ dnorm(0, 0.01) }
	for (s in 1:S) { zeta[s] ~ dnorm(0, 0.01) }
	for (p in 1:P) { sigma_rand[p] ~ dt(0, 1, 3) T(0,) }

	## Priors for correlations
		for (p in 1:1) {
			zscore[p] ~ dnorm(0, 1)
			rho_vec[p] <- tanh(zscore[p])
		}

	## Map correlation vector to matrix using direct indexing
		for (j in 2:2) {
			for (i in 1:(j-1)) {
				R[i,j] <- rho_vec[ (j-1)*(j-2)/2 + i ]
				R[j,i] <- R[i,j]
			}
		}
		for(p in 1:P) { R[p,p] <- 1 }

	## Cholesky decomposition of the correlation matrix
		L[1,1] <- 1
		L[2,1] <- R[2,1]
		L[2,2] <- sqrt(1 - (pow(L[2, 1], 2)))
		L[1,2] <- 0
    }
